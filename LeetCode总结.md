1. 两数之和：只需要找到一个集合，  "找朋友"， hash_map存储每个元素。

15. 三数之和：要找到所有集合，先排序，通过排序可以去重。然后将第i个元素作为最小元素，用对撞指针在之后的元素中和为`-nums[i]`的两个元素。结果中不能有重复的集合，所有不能用上面那种方式（输入数组中有重复元素，"找朋友"这种方法不适用）

18. 四数之和：类似三数之和，加一层循环。

124. 二叉树中的最大路径和：遍历所有节点，计算一个当前节点作为路径的联络节点时的最大路径和，和全局变量做比较。返回的是当前节点作为和父节点的联络节点时的最大值（取一个子节点的返回值，或不取）。（遍历到一个节点时，不要考虑每个节点是否在路径中的情况）（当一个节点的返回值小于0，显然不把 以这个节点作为联络节点的子路径 加入到路径）

146. LRU缓存机制： 查找和删除时间复杂度都要求O(1), 可以想到哈希表和链表。

297. 二叉树的序列化和反序列化：前序遍历做序列化。空格分割每个元素，#表示空指针，不需要记录左右子树的边界。反序列化时，根据空格提取字符串，如果是#就直接返回。反序列化时需要用一个引用（或全局遍历）记录当前处理到的元素的位置。
     

