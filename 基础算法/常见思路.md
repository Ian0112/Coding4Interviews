## 时间复杂度的限制

一般时间复杂度为O(n^2)是不能满足条件的。

一般时间限制是1s，**1s能够做1千万或1万万次的计算量**。一个int表示的最大值是2147483647 （2乘以10的9次方），遍历**int的每个数值**，需要21.5亿*2 = **43亿次。**

在ACM里，题目会告诉数据量，和时间限制，只要能在时间限制内得到正确结果就可以，**根据这个时间限制和数据量，大概就能知道用什么时间复杂度的方法。**



## 数组

对有序的数组，考虑能不能用二分，**双指针**。

考虑正向扫描一遍，再反向扫描一遍。

双指针，可以一前一后同时往一个方向走，可以从中间向两边走，也可以从两边向中间走。

无序的数组，先用`sort()` 排个序会不会容易做。

考虑数组中的每个元素依次做某种位运算，有些位运算满足交换律。

对长度为n的数组，如果每个元素都小于n，尝试利用一下下标。考虑开辟一个额外的空间，用于把数组中的每个元素作为下标，然后做标记，之后再遍历整个用于标记的数组，根据下标是否被标记，判断下标是否满足条件。

对上一条类似问题，还可以考虑把index和value看作一个链表，index看作当前节点，value看作下一个节点。

返回类型为二维数组时，考虑一下，遍历到每个元素时，能否根据当前res中的所有值做修改，如果能就把 每个拷贝出来。

要求不能使用额外空间时，首先想到的是交换数组中的两个元素。有可能需要多个元素之间做交换,比如a->b, b->c, c->d, d->a.  注意会不会要避免重复处理交换一个元素,尤其是二维矩阵. 如果遍历到一个元素时, 操作了4个元素, 注意此时可能只能遍历矩阵的4分之1.

对子数组和问题，可以使用hash map或hash set，其中的key是出现过的前k个子数组的和，k是当前元素i之前的任意元素，遍历到当前元素时，并不知道每个key对应的是具体前几个元素的和，也可能有多个k使得前k个元素的和为key。因为有时并不需要返回具体区间的起点终点, 所有并不需要保存起点终点。

输入的如果是多个区间，考虑是不是需要先根据第一个元素做个排序。

当需要考虑数组的长度为奇数偶数时，优先考虑偶数的情况，比如要求数组中位数时，求两个下标，一个是len/2， 一个是(len-1)/2，长度为偶数时，得到的是不同的下标，长度为奇数时，得到的是两个相同的下标，这两个元素求均值即可。

在一维数组使用DFS时，一般按照顺序遍历数组，遍历到第i个元素时，考虑第i个元素有哪些选择，然后递归处理下一个元素。此时并不需要对第i个元素做标记，只需要记录搜索到了那个下标。

当要求要返回多个vector，并且不能有重复时，考虑让每个vector的元素维持有序。另一种去重的思路是，递归时，考虑能不能从下一个元素开始。

对数组删除元素时，也考虑一下快慢指针，类似快排的写法，把要保留的元素交换到或覆盖到slow之前的区间。



**DFS遍历数组** , 继续遍历有三个条件:

1) 满足题目要求的条件;  2) 访问数组时不能越界; 3) 是否能重复访问

**单调栈: 在一个线性数据结构中，为任意一个元素找左边或右边第一个比自己大/小的位置。**对于数组，栈中一般保存的是下标。 

#### 区间查询

对于给定一个长度为n的数组， 和m次询问， 每次询问都是关于n的一个区间。

用O(n) 做前缀和预处理， O(m) 查询。

#### 字符串

解决两个字符串的动态规划问题，一般都是用**两个指针 `i,j` 分别指向两个字符串的起点**，然后一步步往后走，去求`(i,j)`的状态时，是往前考虑，不要考虑之后的字符。 一般需要用到二维dp，用`dp[i][j]` 表示字符串1取前i个字符，字符串2取前j个字符的情况，开的dp数组大小是(len1+1)*(len2+1)。

用**数组记录字符数量**时，**遍历到一个新字符时，考虑是否能只判断该字符的数量**，而不是查看所有字符的数量。

#### 回文串 

中心扩展法很容易理解。写一个有两个参数的函数，参数表示中心的起点。两个参数相同时，表示回文串是奇数; 两个参数相邻时，表示回文串是偶数。

**hash**

当需要两两比较数组中的元素（元素一般是字符串），可以用hash map来避免两两比较，来获得O(n)的时间复杂度。**unordered_map的key不能是整数数组，但是我们可以把整数数组转成字符数组**，也就是字符串，这时候就可以使用unordered_map了。



#### 滑动窗口

滑动窗口常常和字符串中的词频有关。用一个数组维护窗口的状态，先遍历数组到第一个窗口，作为初始状态，判断是否满足要求； 之后每次遍历到一个新元素，就先删除窗口的第一个元素，还原窗口状态，然后用新元素更新窗口状态，判断是否满足要求。（需要注意满足的要求，比如对子串问题，目标子串中是否有重复字符，如果有重复字符，要match的数量就是字符种类，并且判断每种字符是否match是通过该字符的数量）



## 二叉树

**二叉树的表示:**  一般测试用例会写成以下形式 `[1,null,2,3] ` ,  这种表示方法不是树的遍历序列，而只是一种表示方法。array[2i+1] 表示 array[i] 的左子节点， array[2i+2] 表示array[i]的右子节点。如果节点为空，用null表示。



对二叉树的问题，先考虑能不能递归。

遍历时，考虑用三种遍历中的哪种。



用递归时，避免重复对一个节点递归，可以考虑返回一个数组，保存一个节点的多种情况。这算是树状DP的递归实现 。

## 链表

**考虑要操作的节点为头节点或尾节点时的情况**

考虑能否保存修改节点的值，一般修改节点的值是最简单直接的方法。

考虑能否修改链表的指向关系。

考虑翻转链表（翻转的时间复杂度可以是O(n) , 空间复杂度O(1), 有这道题目）。更进一步，可以考虑翻转链表的一部分，不需要额外空间。

考虑能否通过在链表中插入节点实现更快的方法。

考虑建一个环。

环形链表入口：

```c++
        ListNode* pSlow = headA; // 注意快慢节点都初始为head, 先移动再比较。
        ListNode* pFast = headA;
        while( pFast!=nullptr && pFast->next!=nullptr){
            pFast = pFast->next->next;
            pSlow = pSlow->next;
            if(pFast==pSlow)
                break;
        }
        ListNode* pInter = headA;
        while(pInter!=nullptr && pSlow!=nullptr && pInter!=pSlow){
            pInter = pInter->next;
            pSlow = pSlow->next;
            
        }
```

空间复杂度O(1) 反转链表: 

```c++
// 关键思路是改变链表的指向关系，比如1->2->3->4  变成 1<-2<-3<-4;
// 而不是像数组一样，想着交换头尾的两个元素;
// 反转后的链表，头节点的地址变成了原始链表最后一个节点的地址
        ListNode* pPre = nullptr;
        ListNode* pNode = head; // pNode是每次循环要修改next的节点
        ListNode* pNext = pNode->next; // pNext表示下一个要修改next的节点
		// 每次循环只修改一个节点的指向关系，也就是一个节点的next
        while(pNode!=nullptr){
            pNext = pNode->next;
            pNode->next = pPre;
            pPre = pNode;
            pNode = pNext;
        }
        return pPre; // 此时pNode为空指针，应该返回前一个节点
```



## 连续子序列问题

对连续子序列问题，1)考虑以第i个元素为末尾的**最优情况**，和之前最优情况的关系。 2) 以第i个元素为末尾的最优情况，和以第i-1个元素为末尾的最优情况的关系。



## 整数的边界判断

有的题目需要求解满足特定条件的整数，需要判断int类型的上下边界，int的边界是 [0x80000000, 0x7FFFFFFF]。

1) 最方便的方法是用long long 来保存中间变量，最后再判断是不是在int的范围内。

2) 思考一下能不能把输入转成负数来做。因为负数表示的范围比正数多一个。如果把输入转成正数，最后的结果再转成整数，判断会很麻烦。

**输入有符号数，取绝对值时，要考虑负数会不会溢出。**



## 位运算

$2^n \times k = k << n $, 这种方法可以代替乘法。

位运算也要考虑是不是会溢出，尤其是移位时。



## 常见数据结构操作的时间复杂度

 ![在这里插入图片描述](https://img-blog.csdnimg.cn/20190416122818393.png) 



### DFS

**我常常犯的一个错误是，遍历到最后一个元素时，还没判断，就返回了。**

还有一个错误是，有时候下一步不能继续走时，应该直接返回false。

对数组搜索时，避免对一个区间重复搜索，可以做**记忆化搜索**，这样做其实类似动态规划，**只不过DFS代码比较容易改成记忆化搜索**。举个例子，在一维数组中搜索时，DFS函数传入一个引用数组，搜索到第i个元素，再往后搜索时，先对或者引用数组进行判断，看是否出现过了重复情况，避免重复搜索。 (leetcode 139)



#### 贪心

似乎遇到的几道要用贪心的题目，**每个个体都是有两个属性，然后根据这两个属性中的一个**，从大到小考虑，或从小到大考虑。 然后结合具体问题背景，想出一个策略。



## 不同系列问题

#### 1 数组面积

这类问题从**第i个元素对应的面积如何计算**来想

11 盛最多水的容器

42 接雨水

84 柱状图中最大的矩形

#### 2 股票交易



#### 3 滑动窗口

438 找到字符串中所有字母异位词

76 最小覆盖子串

#### 4 会议室分配问题（贪心）

252 会议室 

253 会议室II



#### 5 丑数问题

丑数的定义是不同的，简单的定义是因数只包含2，3，5的数。

263 丑数

264 丑数II

1201 丑数III（二分，和前面的思路有区别）





## 全排列

首先知道全排列的意义是什么？

**全排列就是，把所有元素的组合，按照字典序排列。**

如果是多个数字的全排列，其实就是把所有的组合按照从小到大排序。

