## 时间复杂度的限制

一般时间复杂度为O(n^2)是不能满足条件的。

一般时间限制是1s，**1s能够做1千万或1万万次的计算量**。一个int表示的最大值是2147483647 ，遍历**int的每个数值**，需要21.5亿*2 = **43亿次。**

在ACM里，题目会告诉数据量，和时间限制，只要能在时间限制内得到正确结果就可以，**根据这个时间限制和数据量，大概就能知道用什么时间复杂度的方法。**





## 数组

对有序的数组，考虑能不能用二分，双指针。

双指针，可以一前一后同时往一个方向走，可以从中间向两边走，也可以从两边向中间走。

无序的数组，先用`sort()` 排个序会不会容易做。

考虑数组中的每个元素依次做某种位运算，有些位运算满足交换律。

对长度为n的数组，如果每个元素都小于n，尝试利用一下下标。

返回类型为二维数组时，考虑一下，遍历到每个元素时，能否根据当前res中的所有值做修改，如果能就把 每个拷贝出来。

要求不能使用额外空间时，首先想到的是交换数组中的两个元素。有可能需要多个元素之间做交换,比如a->b, b->c, c->d, d->a.  注意会不会要避免重复处理交换一个元素,尤其是二维矩阵. 如果遍历到一个元素时, 操作了4个元素, 注意此时可能只能遍历矩阵的4分之1.

对子数组和问题，可以使用hash map或hash set，其中的key是出现过的前k个子数组的和，k是当前元素i之前的任意元素，遍历到当前元素时，并不知道每个key对应的是具体前几个元素的和，也可能有多个k使得前k个元素的和为key。因为有时并不需要返回具体区间的起点终点, 所有并不需要保存起点终点。

**DFS遍历数组** , 继续遍历有三个条件:

1) 满足题目要求的条件;  2) 访问数组时不能越界; 3) 是否能重复访问



#### 区间查询

对于给定一个长度为n的数组， 和m次询问， 每次询问都是关于n的一个区间。

用O(n) 做前缀和预处理， O(m) 查询。



## 二叉树

**二叉树的表示:**  一般测试用例会写成以下形式 `[1,null,2,3] ` ,  这种表示方法不是树的遍历序列，而只是一种表示方法。array[2i+1] 表示 array[i] 的左子节点， array[2i+2] 表示array[i]的右子节点。如果节点为空，用null表示。



对二叉树的问题，先考虑能不能递归。

遍历时，考虑用三种遍历中的哪种。





## 链表

考虑能否保存修改节点的值，一般修改节点的值是最简单直接的方法。

考虑能否修改链表的指向关系。

考虑能否通过插入节点实现更快的方法。

环形链表入口：

```c++
        ListNode* pSlow = headA; // 注意快慢节点都初始为head, 先移动再比较。
        ListNode* pFast = headA;
        while( pFast!=nullptr && pFast->next!=nullptr){
            pFast = pFast->next->next;
            pSlow = pSlow->next;
            if(pFast==pSlow)
                break;
        }
        ListNode* pInter = headA;
        while(pInter!=nullptr && pSlow!=nullptr && pInter!=pSlow){
            pInter = pInter->next;
            pSlow = pSlow->next;
        }
```





## 连续子序列问题

对连续子序列问题，1)考虑以第i个元素为末尾的**最优情况**，和之前最优情况的关系。 2) 以第i个元素为末尾的最优情况，和以第i-1个元素为末尾的最优情况的关系。



## 整数的边界判断

有的题目需要求解满足特定条件的整数，需要判断int类型的上下边界，int的边界是 [0x80000000, 0x7FFFFFFF]。

1) 最方便的方法是用long long 来保存中间变量，最后再判断是不是在int的范围内。

2) 思考一下能不能把输入转成负数来做。因为负数表示的范围比正数多一个。如果把输入转成正数，最后的结果再转成整数，判断会很麻烦。

**输入有符号数，取绝对值时，要考虑负数会不会溢出。**



## 位运算

$2^n \times k = k << n $, 这种方法可以代替乘法。

位运算也要考虑是不是会溢出，尤其是移位时。



