## 排序和常见问题

| 算法     | 时间复杂度 | 常见问题                             | 排序稳定性* |
| -------- | ---------- | ------------------------------------ | ----------- |
| 快速排序 | O(NlogN)   | 找第k大的数，找k个大的数             | 不稳定      |
| 归并排序 | O(NlogN)   | 求逆序数对数, 有序数组合并, 链表排序 | 稳定        |
| 堆排序   | O(NlogN)   |                                      | 不稳定      |

*排序稳定性指的是，对于值相同的多个元素，排序后不改变相对顺序。

参考 LeetCode对各种排序算法的介绍 https://zhuanlan.zhihu.com/p/52884590 

## 理解

**1) 归并排序** 

**关键是如何把两个有序数组合并为一个有序数组**，这个过程不复杂，类似双指针，每个数组一个指针，较小的值被取出来，然后对应的指针加1.

在递归的过程中，只要区间长度大于1，就递归调用归并排序，获得两个有序数组，然后将两个有序数组合并。

```java
void merge(int arr[], int l, int m, int r) 
{ 
    // 把两个区间[l, m], [m+1, r]的有序数组合并为一个有序数组
    int i, j, k; 
    int n1 = m - l + 1;  // 区间1的长度
    int n2 =  r - m; //区间2的长度

    int L[n1], R[n2]; 
	// 从一个数组中，把两个区间的元素拷贝出来作为两个数组
    for (i = 0; i < n1; i++) 
        L[i] = arr[l + i]; 
    for (j = 0; j < n2; j++) 
        R[j] = arr[m + 1+ j]; 

    i = 0; 
    j = 0; 
    k = l; 
    // 从两个有序数组中选出合适的元素放到排序后的第一个，这个写法就是双指针.
    while (i < n1 && j < n2) 
    { 
        if (L[i] <= R[j])  // 当两个有序数组的元素相等时,取左数组中的元素,保证了排序稳定性
        { 
            arr[k] = L[i];  
            i++; 
        } 
        else
        { 
            arr[k] = R[j]; 
            j++; 
        } 
        k++; 
    } 
  	
    // 把左数组中剩下的元素赋值到合并的数组之后
    while (i < n1) 
    { 
        arr[k] = L[i]; 
        i++; 
        k++; 
    } 
  
    // 两个排序数组都可能剩下元素, 此时剩下的元素是相等的.此时先将左数组中的元素赋值到合并数组,再将右数组赋值到合并数组. 保证了排序稳定性
    while (j < n2) 
    { 
        arr[k] = R[j]; 
        j++; 
        k++; 
    } 
} 
  
void mergeSort(int arr[], int l, int r) 
{ 
    // l, r表示区间[l, r]
    if (l < r) 
    { 
        int m = l+(r-l)/2; 
  
        mergeSort(arr, l, m); 
        mergeSort(arr, m+1, r); 
  
        merge(arr, l, m, r); 
    } 
} 
```

归并排序的时间复杂度如何计算?

不严谨的计算: 一次合并的时间复杂度是O(N), 每次递归调用时, 处理的数组长度缩短一半, 直到为1. 记k为递归的此时, 有N/(2^k) = 1, k等于  $log_2N$ , 也就是递归的时间复杂度是O(logN), 每次合并的时间复杂度是线性的,也就是O(N), 整体时间复杂度是O(NlogN).

**2) 快速排序**

