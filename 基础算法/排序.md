## 排序和常见问题

| 算法     | 时间复杂度 | 常见问题                          | 排序稳定性* |
| -------- | ---------- | --------------------------------- | ----------- |
| 快速排序 | O(NlogN)   | 找第k大的数，找k个大的数          | 不稳定      |
| 归并排序 | O(NlogN)   | 493翻转对, 有序数组合并, 链表排序 | 稳定        |
| 堆排序   | O(NlogN)   |                                   | 不稳定      |

*排序稳定性指的是，对于值相同的多个元素，排序后不改变相对顺序。

参考 LeetCode对各种排序算法的介绍 https://zhuanlan.zhihu.com/p/52884590 

## 理解

**1) 归并排序** 

**关键是如何把两个有序数组合并为一个有序数组**，这个过程不复杂，类似双指针，每个数组一个指针，较小的值被取出来，然后对应的指针加1.

在递归的过程中，只要区间长度大于1，就递归调用归并排序，获得两个有序数组，然后将两个有序数组合并。

```java
void merge(int arr[], int l, int m, int r) 
{ 
    // 把两个区间[l, m], [m+1, r]的有序数组合并为一个有序数组
    int i, j, k; 
    int n1 = m - l + 1;  // 区间1的长度
    int n2 =  r - m; //区间2的长度

    int L[n1], R[n2]; 
	// 从一个数组中，把两个区间的元素拷贝出来作为两个数组
    for (i = 0; i < n1; i++) 
        L[i] = arr[l + i]; 
    for (j = 0; j < n2; j++) 
        R[j] = arr[m + 1+ j]; 

    i = 0; 
    j = 0; 
    k = l; 
    // 从两个有序数组中选出合适的元素放到排序后的第一个，这个写法就是双指针.
    while (i < n1 && j < n2) 
    { 
        if (L[i] <= R[j])  // 当两个有序数组的元素相等时,取左数组中的元素,保证了排序稳定性
        { 
            arr[k] = L[i];  
            i++; 
        } 
        else
        { 
            arr[k] = R[j]; 
            j++; 
        } 
        k++; 
    } 
  	
    // 把左数组中剩下的元素赋值到合并的数组之后
    while (i < n1) 
    { 
        arr[k] = L[i]; 
        i++; 
        k++; 
    } 
  
    // 两个排序数组都可能剩下元素, 此时剩下的元素是相等的.此时先将左数组中的元素赋值到合并数组,再将右数组赋值到合并数组. 保证了排序稳定性
    while (j < n2) 
    { 
        arr[k] = R[j]; 
        j++; 
        k++; 
    } 
} 
  
void mergeSort(int arr[], int l, int r) 
{ 
    // l, r表示区间[l, r]
    if (l < r) 
    { 
        int m = l+(r-l)/2; 
  
        mergeSort(arr, l, m); 
        mergeSort(arr, m+1, r); 
  
        merge(arr, l, m, r); 
    } 
} 
```

归并排序的时间复杂度如何计算?

不严谨的计算: 一次合并的时间复杂度是O(N), 每次递归调用时, 处理的数组长度缩短一半, 直到为1. 记k为递归的此时, 有N/(2^k) = 1, k等于  $log_2N$ , 也就是递归的时间复杂度是O(logN), 每次合并的时间复杂度是线性的,也就是O(N), 整体时间复杂度是O(NlogN).

归并排序最坏情况和最好情况下时间复杂度都是O(NlogN).  归并排序是可以并行的。也可以用于外部排序。

**2) 快速排序**

从数列中挑出一个元素，称为 “基准”（pivot）;

重新排序数列，所有元素比基准值小的摆放在基准前面，所有元素比基准值大的摆在基准的后面（相同的数可以到任一边）。在这个分区退出之后，小于这个基准值的所有元素都在基准值左边，大于基准值的所有元素都在基准值右边。这个称为分区（partition）操作；

递归地（recursive）把小于基准值元素的子数列和大于基准值元素的子数列排序；

**partition要实现两个目的**， 一是把基准放到数组之间，二是获得这个位置的下标，用于下一次递归。**实现这个操作的，也是通过双指针。** 每次都选定最后一个元素作为基准值，快指针每次都走1（直到倒数第二 个值），当快指针指向的值小于于pivot时，慢指针就加1， 然后快慢指针指向的值做交换。最后再把基准值（也就是数组最后一个值）和慢指针加1的值交换。**这个过程，保证了慢指针指向的每一个值，都是小于基准值的。**



**3) 堆排序**

基于二叉堆(binary heap)这种数据结构的排序，二叉堆是一个完全二叉树，并且所有父节点的值都大于（或小于）子节点。父节点大于子节点的是最大堆，小于子节点的是最小堆。

对于最大堆，根节点就是最大元素。**用一个一维数组表示二叉堆。**

建堆的时间复杂度是O(n). 

建堆完成后，堆的根节点就是最大值。此时再对前n-1个元素建堆，此时相当于把之前的堆，删除根节点，而不是完全重新建堆，这个操作的时间复杂度是O(logN)。重复直到只剩下1个元素，此时时间复杂度是O(logN)+O(log(N-1)) + O(log(N-2)) + ... +O(log1) ， 近似为 O(NlogN)。

