## 思路

寻找下一个丑数时，把前面所有的元素，都乘上2，3，5，然后从中取最小的一个元素，并且该元素大于当前所有丑数的最大值。

这样寻找一个丑数的时间复杂度是`O(3*K)`, 寻找N个丑数的时间复杂度是`O(3*N^2)` 。

**这样做还需要判断得到的元素是否大于当前丑数的最大值，** 能否记录一下，新增丑数后，下一个丑数可能的因子

```
1,2
下一个丑数的因子是1
1,2,3
下一个丑数的因子是2
1,2,3,4
下一个丑数的因子是1
1,2,3,4,5
```



思路不对，放弃。

其实剑指offer上做过这题了，但是还是不记得了。

**正确的思路**

动态规划， 

新元素的因子，可能是2，3，5。并且另一个因子，是当前已有的丑数。

每个丑数，作为因子，可以使用三次，三次分别是乘上2，3，5。

需要三个变量，单独记录2，3，5对应已有丑数的下标，如果新增的丑数，已经是因子2，3或5和已有丑数的乘积，那么说明**这个已有丑数已经用过了，所以对应的索引要加1**。

**每个丑数都会至少作为一次因子。**





## 代码

```c++
class Solution {
public:
    int nthUglyNumber(int n) {
        vector<int> vec;
        vec.push_back(1);

        int i2 = 0, i3 = 0, i5 = 0; // 表示
        int cnt = 1;
        while(cnt<n) {
            int next = min( min(vec[i2]*2, vec[i3]*3), vec[i5]*5 );
            
            if(next==vec[i2]*2) i2+=1;
            if(next==vec[i3]*3) i3+=1;
            if(next==vec[i5]*5) i5+=1;
            cnt+=1;
            vec.push_back(next);
        }

        return vec[n-1];
    }
};
```

