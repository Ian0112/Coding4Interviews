## 思路

感觉题目说的不是很清楚，好像要求O(n)。

应该不需要快排就能做。

应该可以O(n), 类似快排的写法，用双指针，把小于基准值的元素放到左边，大于基准值的元素放到右边。如果选择任意一个1作为基准值，可能调整之后，1左侧的数据出现0,1交替的情况。

~~我们可以选择第一个出现的1作为基准值，把它交换到数组末尾。用slow记录数组中小于等于1的最后一个元素的位置，用fast表示每个元素。当fast小于等于基准值1时，把它和slow的下一个元素交换, slow+1。~~  这样也会有问题，无论选哪个位置的1，都不能保证0,1是完全有序的，只能保证2是在1后面。

所以我们可以先把所有的2处理好，在对所有的0,1用双指针做一遍交换。

**能不能直接用三个指针做?**

记录等于0的元素的终点，记录等于2的元素的起点。等于0就交换到0所在区间的终点+1位置，等于2就交换到2所在区间的起点-1的位置。





## 代码

先把0处理好，然后在剩下的区间里处理1，时间复杂度O(2n), 但是比调sort函数慢。

```c++
class Solution {
public:
    void sortColors(vector<int>& nums) {
        if(nums.empty())
            return;

        int idx0=-1, idx1=-1;
        for(int i=0;i<nums.size();i++){
            if(nums[i]==0){
                idx0+=1;
                swap(nums[i], nums[idx0]);
            }
        }

        idx1 = idx0;
        for(int i=idx0+1;i<nums.size();i++)
        {
            if(nums[i]==1){
                idx1+=1;
                swap(nums[i], nums[idx1]);
            }
        }
        return;
    }
};
```

三指针，跟上面的速度差不多，也比sort慢

```c++
代码不放了，感觉没意思。。
```

