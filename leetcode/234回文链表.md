## 思路

要求时间复杂度为O(n), 空间复杂度为O(1).

空间复杂度O(1)有点难想。链表只能从前往后顺序访问。应该是用双指针，因为也没有其他的好方法。

双指针，快指针每次走两步，慢指针每次走一步. 快指针走到末尾时，慢指针应该正好走到中间位置。

对`1->2->2->1` 。

没什么思路。

**正确的思路**

把链表的一半元素**翻转**。 翻转后，就能按照顺序比较两部分是不是相同。翻转链表可以做到时间复杂度为O(n), 和空间复杂度为O(1)。

考虑一下长度为奇数偶数时，用不用特殊处理。

举例`1->2->3->4` , 

fast	= 1, 3, nullptr

slow	=  1, 2, 3

举例`1->2->3->4->5`

fast = 1, 3, 5

slow = 1, 2, 3

此时直接翻转以slow为头节点的链表，不需要考虑链表总长度是奇数还是偶数。

