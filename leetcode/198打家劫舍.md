## 思路

根据题意，不能选择相邻元素。

并且数组中都是非负数，所有元素越多越好。 

~~所有索引为奇数的和，和所有索引为偶数的和，取较大的即可。~~

**上面这种思路是错误的，因为比如对`[2,1,1,2]` , 此时的最佳选择是取第一个和最后一个元素。**

**正确的思路**

动态规划。 如果只有1个元素，那么就选择这个元素； 如果有两个元素，选择其中的最大值；如果有三个元素，选择  max(第一个元素加第三个元素， 前两个元素的最大值). **可以发现对于第k（比如k=3）个元素，不管前面有多少个元素，只需要选择max(前k-2个元素的最大和加上该元素， 前k-1个元素的最大和)。**

时间复杂度O(n), 空间复杂度O(n). 空间复杂度可以变成O(1)， 只保留两个临时变量，表示前i-2个元素最大和，前i-1和元素最大和。

## 代码

```c++
class Solution {
public:
    int rob(vector<int>& nums) {
        if(nums.empty())
            return 0;

        int lenth = nums.size();
        int tSum[lenth] = {0};
        tSum[0] = nums[0]; // 前1个元素
        if(lenth==1) return nums[0];

        tSum[1] = max(nums[0], nums[1]); // 前2个元素
        for(int i=2;i<lenth;i++){
            tSum[i] = max(tSum[i-2]+nums[i], tSum[i-1]);
        }
        return tSum[lenth-1];
    }
};
```

