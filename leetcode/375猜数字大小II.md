## 思路

输入一个长度n，输出的是多少钱。长度为n时，答案可以是1-n的任意一个元素x，此时最坏要支付多少钱？

当n = 1时，需要0元；

当n = 2时，如果答案为1，最坏需要2元，如果答案为2，最坏需要1元；

当n = 3时，如果答案为1，最坏需要3+2元，答案为2，最坏需要1+3元， 答案为3，最坏需要1+2元。 如果有2+3元，不管答案是多少，都能赢。

当n=4时，如果答案为1，最坏需要4+3+2元， 答案为2, 最坏需要1+4+3元， ... 。所以如果有4+3+2元，不管答案为多少，都能嬴。

上面这种方式去猜数字太傻了，我们可以用二分法模拟猜数字x的过程，记录模拟过程中花费的钱。然后从1到n遍历x，得到x每种取值时的花费，然后从花费中取最大花费，就能保证胜利。

但在猜数字x时，是不是有比二分更好的方法，能有更低的成本？

**正确的思路**

**对于至少...才能保证...问题，我们需要获得遇到最坏情况时的最优选择，所以我们可以在做每次选择时，比较哪种选择更好，成本更低。在计算一种选择的成本时，考虑遇到最坏的情况，如何进行下一次选择，这样没做一次选择，下一次可选的方案就会变少，直到只剩一种选择，或者是不再需要计算成本，而是可以直接作出选择。**

这题目比较难理解。如果有两个元素[1, 2]， 猜数字时有两种选择，一是猜1，二是猜2。如果猜1，答案如果为1，那么成本为0，如果答案为2，那么成本为1； 如果猜2，答案如果为1，那么成本为2，如果答案为2，那么成本为0。

所以我们在不知道答案的前提下，肯定选择猜1这种方式。此时成本只需要为1即可保证胜利。**在用这种思路时，我们是遍历每一个元素，作为本次要猜的元素，然后遍历剩下的可猜的元素，作为第二次猜的元素，并且我们每次猜都是猜不中的，也就是只有当可猜的元素只有一个时，就返回。**

如果有3个元素[1, 2, 3],  猜第一个数字时有3种选择，猜1, 2, 3。 如果猜1，那么之后可以猜2或3， 此时不管答案为几，我们一定是猜2的，因为猜2时，成本为2或0， 猜3时成本为3或0。所以第一次猜1的最低成本是3。如果猜2，那么之后不需要猜，因为只剩一个元素了。

如果有4个元素[1,2,3,4], 第一次猜1，之后猜3。第一次猜2，第二次猜3。第一次猜3，第二次猜1，第一次猜4，第二次猜2. 最小成本是4。

有一个规律是，如果剩2个元素，成本就是那个较小的那个元素，如果剩3个元素，那么最小成本是中间那个元素。



## 代码

1) 时间复杂度 O(n!),  每层递归，循环数就会少1。

空间复杂度是 O(n): n层递归的开销

逻辑没问题，但是leetcode上n=20时就会超时。

这种方法相当于暴力dfs。

```c++
class Solution {
public:
    int getMoneyAmount(int n) {
        if(n<0)
            return 0;
        else
            return getMoney(1, n);
    }
    
    int getMoney(int start, int end)
    {
        if(end<=start)
            return 0;
        if(end-start == 1)
            return start;
        if(end-start == 2)
            return end-1;
        
        int mMin = INT_MAX;
        for(int i=start;i<=end;i++)
        {
            int mBad = i+max( getMoney( start , i-1) , getMoney(i+1, end) );
            // 比如[1, 2, 3, 4], 选2后, 要保证能赢, 考虑的是从[3,4]中如何选，而不是从[1]中如何选。
            
            mMin = min(mMin, mBad);
            // 选择了元素i之后, mBad是考虑了最坏情况时，做出的最佳选择, 
            // 如果选择了元素i后, 成本比选择其他元素要高，那么就不选元素i
        }
        return mMin;
    }
};
```

2) 对暴力方法进行剪枝:

在[start, end]中做选择时，这个剪枝真的看不懂，感觉就是贪心的做法。

当n=29时，线上也过不了了。

```c++
class Solution {
public:
    int getMoneyAmount(int n) {
        
        if(n<0)
            return 0;
        else
            return getMoney(1, n);
        
    }
    
    int getMoney(int start, int end)
    {
        if(end<=start)
            return 0;
        if(end-start == 1)
            return start;
        if(end-start == 2)
            return end-1;
        
        int mMin = INT_MAX;
        for(int i=start+(end-start)/2;i<= end;i++)
        {
            int mBad = i+max( getMoney( start , i-1) , getMoney(i+1, end) );
            // 比如[1, 2, 3, 4], 选2后, 要保证能赢, 考虑的是从[3,4]中如何选，而不是从[1]中如何选。
            
            mMin = min(mMin, mBad);
            // 选择了元素i之后, mBad是考虑了最坏情况时，做出的最佳选择, 
            // 如果选择了元素i后, 成本比选择其他元素要高，那么就不选元素i
        }
        
        return mMin;
    }
};
```

