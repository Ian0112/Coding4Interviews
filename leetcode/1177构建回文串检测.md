## 思路

题目比较长,  先好好理解一下:

对一个子串，可以重新排列字串，并且选择k项替换成任意字母。如果能够通过这种才做变成回文形式的字符串，那么检测结果为true。

要返回的是一个数组，其中第i个元素是第i个字串的检测结果。

不能修改原始字符串s。

没思路，最基本的回文串判断都不会写了。

**这道题目不用从回文子串来想，因为有两个变换规则，并且全部是小写字母(最多26种字符)，** 并不需要想着怎么去把这个字符串，去做这两种变换后，再判断是不是回文。 

而是要找规律，直接判断什么样的子串，能满足这个条件。

举例说明:

对"abcde"或者"edcba", 其中有5个字符，只要能替换2个，就能变成回文子串;对"abcd", 也是替换两个就能变成回文串; 对有重复的字符串，比如"abcaa", 对于成对的字符，通过交换位置就能实现回文，所以把成对字符去掉，剩下的所有子串，长度除以2，就是变成回文串所需要的替换次数。

**如何去除成对字符?**

并不需要在字符串上做去除，只需要统计每种字符的出现次数，出现次数为奇数的字符，就是剩下的字符，统计出现次数为奇数的字符的数量即可。

**一共有26个字符，出现次数为奇数的字符最多26个，26/2=13， 也就是最多需要替换13个字符，当k>=13时，子串一定能变成回文。**

这种暴力判断每个query的方法，当query很多时，会超时。应该想到的是，不同区间，有重复的部分。



**进一步优化**

我们需要统计每个字符出现次数，用int来表示有上限，可以用异或来判断出现次数。开一个长度为26的数组，对每个字符，初始状态为0，每次遇到相同字符，就和该字符做一次异或。最后异或结果不为0的字符，就是出现了奇数次。



## 代码

暴力判断每个query。

```c++
class Solution {
public:
    vector<bool> canMakePaliQueries(string s, vector<vector<int>>& queries) {
        vector<bool> ret;
        for(auto vec:queries){
            ret.push_back( isPalindrome(s, vec[0], vec[1], vec[2]) );
        }
        return ret;
    }

    bool isPalindrome(string& s, int left, int right, int k){
        if(k>=13) return true;
        int charCnt[26] = {0};
        for(int i=left;i<=right;i++)
            charCnt[ s[i]-'a' ]+=1;
        
        int needReplace = 0;
        for(int i=0;i<26;i++)
            if(charCnt[i]%2)    needReplace+=1;

        return (needReplace/2)<=k;
    }

};
```

