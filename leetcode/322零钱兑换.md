## 思路

可以dfs，



## 代码

dfs, 时间复杂度O(amount^n)

```c++
class Solution {
public:
    int coinChange(vector<int>& coins, int amount) {
        if(coins.empty()) return -1;
        int ret = INT_MAX;

        dfs(coins, amount, 0, ret);
        return ret==INT_MAX?-1:ret;
    }

    void dfs(vector<int> &coins, int amount, int count, int &ret) {
        if(amount==0){
            ret = min(ret, count);
            return;
        }

        for(int i=0;i<coins.size();i++){
            if(amount >= coins[i])
                dfs(coins, amount-coins[i], count+1, ret);
        }

        return;
    }
};
```

