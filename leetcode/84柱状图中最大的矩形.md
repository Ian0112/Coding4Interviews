## 思路

这道题和 11题（盛最多水的容器）相比，11题的面积只需要考虑区间两个边界中较短的边，但是这个题目需要考虑的是 **区间内最短的边**。

举例  `[2,1,5,6,2,3]` 

暴力： 以第1个元素为起点，计算以之后每个元素为终点的区间。取面积最大的区间。

单调栈：

先不管怎么思考的，直接套单调栈。

做比较时，要取较小的值，所有用递增栈。

从后往前遍历，模拟一下递增栈的情况：

**放弃**

**看题解也看不懂**

一个关键的想法是，**如何找到以每个元素为高的最大矩形？** 有两个条件：

1）在这个矩形中，元素i就是最小的元素

2）并且这个矩形两侧的值小于元素i（因为如果大于元素i，这个矩形就可以继续向两侧扩展）。

从这里我们可以想到用单调栈来做，单调栈中存储比栈顶元素小的元素，**这些出现在第i个元素之前，并且比第i个元素小，肯定不会参与构成以第i个元素为高的矩阵。**

对`[2,1,5,6,2, 3]` ,  栈的变换应该是`[] -> [2] -> [1] ->[1,5,6]->[1,2]->[1,2,3]`

可以发现，在`[1,5,6]->[1,2]`，也就是当第5个元素2入栈时，第4个元素6和第3个元素5都要出栈，**当第3个元素5出栈后，新的栈顶元素1比5小，并且要入栈的第5个元素2，也比5小，此时恰好是以5为高的矩阵的最大面积。**

最关键的操作是： **当新元素比栈顶元素小时，栈顶元素先出栈，然后计算以栈顶元素为高的矩形面积。矩形的宽是新元素下标减去新栈顶下标。**

**出错的地方：**

1） 数组可能是一个递增数组或者最后一段是递增的，导致每个新元素都大于之前元素，就可以一直入栈，不会出栈，我们只会在出栈时计算面积。一个便捷的方法是在原数组上push_back一个0。

2）计算以栈顶元素为高的矩形面积时，保存栈顶元素后，要出栈，通过新栈顶元素来计算宽度，如果出栈后栈为空，说明在这个高之前，数组中的所有元素都大于这个高，可以参与组成这个矩形，所以此时的宽度就是新元素的下标i。

## 代码

```c++
class Solution {
public:
    int largestRectangleArea(vector<int>& heights) {
        stack<int> st;
        if(heights.empty())
            return 0;

        heights.push_back(0);
        int lenth = heights.size();
        int ret = 0;

        for(int i=0;i<lenth;i++){
            int val = heights[i];
            while(!st.empty() && heights[st.top()] >= val ){
                int h = heights[st.top()]; // 高是栈顶元素
                st.pop();
                // 当栈为空时，宽就是下标i。
                // 因为栈为空，说明数组中，出现在元素h之前的元素都大于h，可以参与组成以h为高的矩形
                // 当栈不为空时，宽是第i个元素减去新栈顶元素（新栈顶元素的值比h小）
                int w = st.empty()?i:(i-st.top()-1); 
                ret = max(ret, h*w);
            }
            st.push(i);
        }

        return ret;
    }
};
```

