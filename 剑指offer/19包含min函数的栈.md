## 思路

先确认一下，获得栈中所含最小元素时，是否要弹出这个元素。

应该是不弹出的，如果要弹出的话，这个数据结构就不是栈了。



1) 入栈

所以可以设置一个变量，保存栈中的最小值。

在入栈时，如果栈为空，就把最小值设为入栈的这个元素。

如果栈不为空，就比较最小值和新入栈的元素。

2) 出栈

出栈时，如果栈顶元素是最小值，弹出最小值后，需要获得一个次小值，将最小值赋值为次小值。

如果栈顶元素不是最小值，就直接弹出。

**如何获得次小值，其实也就是最小值弹出后怎么获得最小值呢?** 入栈过程中保存? 那弹出最小值后，次小值如何获得? 只能遍历一遍栈，得到次小值。这样复杂度编程O(n)了。

**我们可以保存一个次小值，在最小值弹出后，将最小值赋值为这个次小值。然后更新这个次小值时，需要一个第三小的值。这样依次循环，我们还是需要为栈中的每个元素排序。能不能利用一个数据结构，来保存栈中的排序的元素？**

此时可以用一个辅助栈，在入栈时，如果新入栈的元素，小于最小值，就在入栈的同时, push进这个辅助栈。如果大于最小值，辅助栈就push一个当前最小值，也就是栈顶元素。

在出栈时，数据栈和辅助栈都pop即可。

**辅助栈的作用，其实是记录数据栈的每个状态下的最小值，所以辅助栈的大小一直和数据栈的大小是相同的。**



## 代码

```c
class Solution {
public:
    stack<int> m_data;
    stack<int> m_min;
    void push(int value) {
        m_data.push(value);
        if( (m_min.empty()) ||(m_min.top() > value) )
        {
            m_min.push(value);
        }
        else{
            m_min.push( m_min.top() );
        }
    }
    void pop() {
        m_data.pop();
        m_min.pop();
    }
    int top() {
        if(!m_data.empty())
        {
            return m_data.top();
        }
        else{
            return -1;
        }
    }
    int min() {
        if( !m_min.empty() )
        {
            return m_min.top();
        }
        else{
            return -1;
        }
    }
};
```

