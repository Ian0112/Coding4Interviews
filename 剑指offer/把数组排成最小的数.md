## 思路

 暴力，依次比较每种排列，然后获得最小值。 这样肯定不好。

~~找规律，思考什么样的元素会被放在第一位。发现是由首字母决定的，首字母最小的，放在首位。如果首字母相同，比较第二个字母，取较小的。如果两个数字，从前往后几位都相同，其中一个数字比另一个数字长，则用多余出来的部分，和~~

可以递归，获得最小元素放在最前面，之后获得剩余数据的最小元素放在次前。

不太好写，如何得到放在首位的元素。



**正确的思路:**

把两个数字拼接到一起，比较谁在前更好。要考虑到大数，也就是两个整数拼接起来后超过32位，所有需要转换成字符串进行比较。先将整数数组转换为字符串数组，写qsort的回调函数来对整个字符串数组排序，复杂度为O(nlogn)。

这里定义了，**一种新的比较两个数字大小的规则**，也就是排序后，第一个数字和其他数字拼接起来时，放在前面更好。那这样得到的数组，就是拼接起来后的最小数组吗？这里需要用反证法，先假设得到的是最小数组，**这个数组中的任意两个元素满足定义的比较规则，**然后通过相邻的元素的交换，可以得到任意其他排列的数组，任意其他排列的数组都比这个最小数组大。



