## 思路

1) 循环32次，依次判断每位是不是1。考虑到负数左移，高位会补1，只要将输入保持不变，对数字1进行左移，然后每位依次判断就可以了。

2) 位运算常见的一个操作是，**数据减1然后和自身做与运算**。这样可以消去位置在最右边的1。负数怎么处理？**这一点对负数也是同样适用的，**比如对8位有符号数，一直减1到其下限-128，二进制为1000_0000，此时减1会变成0111_1111，与1000_0000做与运算，就变成0。这样运算知道n变成0，由于每次都消去最右边的1，**消去的次数就是二进制中1的个数。** **十进制减1，不管是正负，二进制都是直接减1。**

## 代码

1)

```c
class Solution {
public:
     int  NumberOf1(int n) {
         int cnt=0;
         for(int i=0;i<32;i++)
         {
             if(n&(1<<i))
                 cnt++;
         }
         return cnt;
     }
};
```

2) 

```c
class Solution {
public:
     int  NumberOf1(int n) {
         int cnt=0;
         while(n)
         {
             cnt++; // 消去1的次数就是1的个数
             n = (n-1)&n;
         }
         return cnt;
     }
};
```

## 总结

1) 二进制相关的题目考虑负数。

2) `while(n)`, n为负数也是真，只有为0才是假。

3) int类型表示的范围是 -2^31 -- 2^31-1，1000_0000_0000_... 表示的是 -2^31，其减1会变成0111_1111_1111...，也就是 -2^31减1变成2^31-1。也就是**有符号数下溢后会变成上限**。

4)  **十进制减1，不管是正负，二进制都是直接减1。**